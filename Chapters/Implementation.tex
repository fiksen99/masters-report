
\chapter{Implementation} % Main chapter title

\label{Implementation} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\lhead{Chapter 3. \emph{Implementation}} % Change X to a consecutive number; this is for the header on each page - perhaps a shortened title

\section{Preparation of source code}

The students' code is currently stored as a directory of folders, one folder for
each student. Within each student folder, we find the bare git repositories of 
each exercise. Given that the tool is specifically aimed at aiding the lab helpers,
we wanted to automate a way to get this code into eclipse to be used by our plugin.
If the initial work to import the code to Eclipse was too long winded and tedious,
our tool would probably add more time to the analysis of the code, and divert markers'
attention away from actually marking the code.

To achieve this a simple bash script was developed. The script requires git and
maven to be installed on the running machine. The script should be run from the
top directory, with the name of the repository to clone passed in as an argument.
A small amount of modification is needed here depending on the structure of the
source code. Assuming the code is located in the default Java package, a folder
named "[repository name]\_[username]" will be created in each student's directory.
Into here we copy a "generic pom" file to be used by Maven. The command line tool
sed modifies this file to substitute a unique project name (of the same format as
the new subdirectory name) and then Maven builds the project with the command 
\texttt{mvn compile eclipse:eclipse}. This will compile the program, then generate
Eclipse project files. From here, we can now open up Eclipse and use the 
\texttt{File->Import->Existing Projects into Workspace} and select the top-level
directory as the root directory, allowing us to easily import all projects.

A clean script is also provided to quickly remove any files and folders created with
the previous script.

\section{Design of plugin}

\subsection{Project Comparison}

Using the plugin extension points,
we create an entry point to our analyser from our own menu item in Eclipse. This
handler passes an array of the projects in the workspace to our similarity analyser.
The analyser has been structured in a modular manner, allowing future extensions
to be created easily. We have a SimilarityAnalyser abstract class, which takes
care of the setting up of the analyser and holds a number of protected variables
to be used by any implementing classes. For example, the scores are held as a
\texttt{double[][] scores} and this is initialised in the SimilarityAnalyser
constructor such that each dimension is set to be the length of the number of
inputted projects. An ordered list keeps track of which user the scores correspond
to. In setting up the analyser, we check for a skeleton project in the directory,
named [project\_name]\_skeleton\_. If this Directory is found, we create a Set,
which will hold the names of unmodified (and therefore uninteresting) code.

Initially the Parse Tree Analyser was set up to iterate over the projects, and
compare each in turn as defined in the equations discussed in the background [TODO:
insert reference to figure here]. Here our implementation makes an assumption about
the algorithm; the algorithm indicates how to get a similarity score between two 
parse trees, however it does not indicate how to perform this measure across a code
base of multiple files. Our implementation finds the maximum similarity of one file
compared with each file from the other project in turn, and uses this value as the
similarity score for that particular parse tree (which is then summed with the similarity
score from each other parse tree). We chose the maximum rather than the mean, as
you might expect with similarity, as the mean method would negatively weight our
similarity even when an exect match is found. For example, if we have a project A
containing 2 files, \texttt{A1.java} and \texttt{A2.java} (which are very different
 to each other) and a similar project B with files \texttt{A1.java} and \texttt{B2.java}.
Even if the files in project A are exactly the same as the corresponding files in
project B, using the mean similarity would give us a value of below a perfect match,
which is undesirable in this context.

Once we have a similarity between every project in our workspace, we need a place
to see our results; this is where 
\texttt{com.imperial.fiksen.codesimilarity.utils.ResultsPrinter.java} comes in.
The SimilarityAnalyser has a print function, which
passes in an OutputStream (usually a stream to the file we want to create) and
there are a number of functions depending on our desired output format; currently
hardcoded to be our Orange output. Once the scores have been outputted, the SimilarityAnalyser
then launches a process of Orange using a generic project setup. This opens a pre-
configured Orange window, holding the distance matrix (i.e. the distance between
each project, or the inverse of their similarities), in a clustered format.

\subsection{Two File Comparison View}

In viewing the distance map and cluster output, we can see pairs of projects that are
interesting -- for example a 

\section{Similarity Analysis}

To perform the actual similarity measure between two files, we use the function 

As discussed in the Background section, our similarity measure is based around an
implementation of a parse tree kernel function. 

\section{Implementation Improvements}
\subsection{Algorithm}

\subsection{Software Engineering}

TODO: heuristic - if named the same then probably the same file, increases speed
